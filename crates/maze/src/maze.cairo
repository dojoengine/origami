//! Maze struct and generation methods.

// Core imports

use core::hash::HashStateTrait;
use core::poseidon::PoseidonTrait;

// Constants

const DIRECTION_SIZE: u32 = 0x10;

/// Maze struct.
#[derive(Destruct)]
pub struct Maze {
    pub width: u8,
    pub height: u8,
    pub grid: felt252,
    pub seed: felt252,
}

/// Errors module.
pub mod errors {
    pub const MAZE_INVALID_DIMENSION: felt252 = 'Maze: invalid dimension';
    pub const MAZE_INVALID_EXIT: felt252 = 'Maze: invalid exit';
    pub const MATH_INVALID_INPUT: felt252 = 'Math: invalid input';
    pub const MATH_INVALID_SIZE: felt252 = 'Math: invalid size';
}

/// Implementation of the `MazeTrait` trait for the `Maze` struct.
#[generate_trait]
pub impl MazeImpl of MazeTrait {
    #[inline(always)]
    fn new(width: u8, height: u8, start: u8, seed: felt252) -> Maze {
        // [Check] Valid dimensions
        assert(width * height <= 252, errors::MAZE_INVALID_DIMENSION);
        // [Check] Start is not a corner and is on an edge
        let mut maze = Maze { width, height, grid: 0, seed };
        maze.assert_not_corner(start);
        maze.assert_on_edge(start);
        // [Effect] Add start position
        maze.grid = Self::set(0, start);
        // [Compute] Generate the maze
        Self::generate(ref maze, start);
        // [Return] Maze
        maze
    }

    #[inline]
    fn generate(ref maze: Maze, start: u8) {
        // [Compute] Generate shuffled neighbors
        let mut directions = Self::compute_shuffled_directions(maze.seed);
        // [Assess] Direction 1
        let direction: u8 = (directions % DIRECTION_SIZE).try_into().unwrap();
        directions /= DIRECTION_SIZE;
        if maze.check_neighbor(start, direction) {
            // [Compute] Add neighbor
            let start = maze.add_neighbor(start, direction);
            maze.seed = Self::reseed(maze.seed);
            Self::generate(ref maze, start);
        }
        // [Assess] Direction 2
        let direction: u8 = (directions % DIRECTION_SIZE).try_into().unwrap();
        directions /= DIRECTION_SIZE;
        if maze.check_neighbor(start, direction) {
            // [Compute] Add neighbor
            let start = maze.add_neighbor(start, direction);
            maze.seed = Self::reseed(maze.seed);
            Self::generate(ref maze, start);
        }
        // [Assess] Direction 3
        let direction: u8 = (directions % DIRECTION_SIZE).try_into().unwrap();
        directions /= DIRECTION_SIZE;
        if maze.check_neighbor(start, direction) {
            // [Compute] Add neighbor
            let start = maze.add_neighbor(start, direction);
            maze.seed = Self::reseed(maze.seed);
            Self::generate(ref maze, start);
        }
        // [Assess] Direction 4
        let direction: u8 = (directions % DIRECTION_SIZE).try_into().unwrap();
        directions /= DIRECTION_SIZE;
        if maze.check_neighbor(start, direction) {
            // [Compute] Add neighbor
            let start = maze.add_neighbor(start, direction);
            maze.seed = Self::reseed(maze.seed);
            Self::generate(ref maze, start);
        }
    }

    #[inline]
    fn add_exit(ref self: Maze, exit: u8) {
        // [Check] Exit is not a corner and on edge
        self.assert_not_corner(exit);
        self.assert_on_edge(exit);
        // [Effect] Add exit at position
        self.grid = Self::set(self.grid, exit);
        // [Effect] Check the next position inside the maze to ensure the exit is reachable
        let (x, y) = (exit % self.width, exit / self.width);
        if x == 0 {
            let position = exit + 1;
            if Self::get(self.grid, position) == 0 {
                self.grid = Self::set(self.grid, position);
            }
        } else if x == self.width - 1 {
            let position = exit - 1;
            if Self::get(self.grid, position) == 0 {
                self.grid = Self::set(self.grid, position);
            }
        } else if y == 0 {
            let position = exit + self.width;
            if Self::get(self.grid, position) == 0 {
                self.grid = Self::set(self.grid, position);
            }
        } else if y == self.height - 1 {
            let position = exit - self.width;
            if Self::get(self.grid, position) == 0 {
                self.grid = Self::set(self.grid, position);
            }
        }
    }

    #[inline]
    fn check_neighbor(ref self: Maze, position: u8, direction: u8) -> bool {
        let (x, y) = (position % self.width, position / self.width);
        match direction {
            0 => (y <= self.height - 4)
                && (x != 0)
                && (x != self.width - 1)
                && (y != self.height - 1)
                && (Self::get(self.grid, position + 2 * self.width) == 0),
            1 => (x <= self.width - 4)
                && (y != 0)
                && (y != self.height - 1)
                && (x != self.width - 1)
                && (Self::get(self.grid, position + 2) == 0),
            2 => (y >= 3)
                && (x != 0)
                && (x != self.width - 1)
                && (y != 0)
                && (Self::get(self.grid, position - 2 * self.width) == 0),
            _ => (x >= 3)
                && (y != 0)
                && (y != self.height - 1)
                && (x != 0)
                && (Self::get(self.grid, position - 2) == 0),
        }
    }

    #[inline]
    fn add_neighbor(ref self: Maze, position: u8, direction: u8) -> u8 {
        let (x, y) = (position % self.width, position / self.width);
        let edge = x == 0 || y == 0 || x == self.width - 1 || y == self.height - 1;
        match direction {
            0 => {
                let mut new_position = position + self.width;
                self.grid = Self::set(self.grid, new_position);
                if !edge {
                    new_position = position + 2 * self.width;
                    self.grid = Self::set(self.grid, new_position);
                }
                new_position
            },
            1 => {
                let mut new_position = position + 1;
                self.grid = Self::set(self.grid, new_position);
                if !edge {
                    new_position = position + 2;
                    self.grid = Self::set(self.grid, new_position);
                }
                new_position
            },
            2 => {
                let mut new_position = position - self.width;
                self.grid = Self::set(self.grid, new_position);
                if !edge {
                    new_position = position - 2 * self.width;
                    self.grid = Self::set(self.grid, new_position);
                }
                new_position
            },
            _ => {
                let mut new_position = position - 1;
                self.grid = Self::set(self.grid, new_position);
                if !edge {
                    new_position = position - 2;
                    self.grid = Self::set(self.grid, new_position);
                }
                new_position
            },
        }
    }

    #[inline]
    fn compute_shuffled_directions(seed: felt252) -> u32 {
        // [Compute] Random number
        let mut random: u32 = (seed.into() % 24_u256).try_into().unwrap();
        // [Return] Pickup a random permutation
        // [Info] 0:Top, 1:Right, 2:Bottom, 3:Left
        match random {
            0 => 0x0123,
            1 => 0x0132,
            2 => 0x0213,
            3 => 0x0231,
            4 => 0x0312,
            5 => 0x0321,
            6 => 0x1023,
            7 => 0x1032,
            8 => 0x1203,
            9 => 0x1230,
            10 => 0x1302,
            11 => 0x1320,
            12 => 0x2013,
            13 => 0x2031,
            14 => 0x2103,
            15 => 0x2130,
            16 => 0x2301,
            17 => 0x2310,
            18 => 0x3012,
            19 => 0x3021,
            20 => 0x3102,
            21 => 0x3120,
            22 => 0x3201,
            _ => 0x3210,
        }
    }

    #[inline]
    fn get(value: felt252, index: u8) -> u8 {
        let value: u256 = value.into();
        let offset: u256 = Self::two_power(index);
        (value / offset % 2).try_into().unwrap()
    }

    #[inline]
    fn set(value: felt252, index: u8) -> felt252 {
        // [Info] Unsafe since the value at index is expected to be null
        let value: u256 = value.into();
        let offset: u256 = Self::two_power(index);
        (value + offset).try_into().unwrap()
    }

    #[inline]
    fn two_power(exp: u8) -> u256 {
        match exp {
            0 => 0x1,
            1 => 0x2,
            2 => 0x4,
            3 => 0x8,
            4 => 0x10,
            5 => 0x20,
            6 => 0x40,
            7 => 0x80,
            8 => 0x100,
            9 => 0x200,
            10 => 0x400,
            11 => 0x800,
            12 => 0x1000,
            13 => 0x2000,
            14 => 0x4000,
            15 => 0x8000,
            16 => 0x10000,
            17 => 0x20000,
            18 => 0x40000,
            19 => 0x80000,
            20 => 0x100000,
            21 => 0x200000,
            22 => 0x400000,
            23 => 0x800000,
            24 => 0x1000000,
            25 => 0x2000000,
            26 => 0x4000000,
            27 => 0x8000000,
            28 => 0x10000000,
            29 => 0x20000000,
            30 => 0x40000000,
            31 => 0x80000000,
            32 => 0x100000000,
            33 => 0x200000000,
            34 => 0x400000000,
            35 => 0x800000000,
            36 => 0x1000000000,
            37 => 0x2000000000,
            38 => 0x4000000000,
            39 => 0x8000000000,
            40 => 0x10000000000,
            41 => 0x20000000000,
            42 => 0x40000000000,
            43 => 0x80000000000,
            44 => 0x100000000000,
            45 => 0x200000000000,
            46 => 0x400000000000,
            47 => 0x800000000000,
            48 => 0x1000000000000,
            49 => 0x2000000000000,
            50 => 0x4000000000000,
            51 => 0x8000000000000,
            52 => 0x10000000000000,
            53 => 0x20000000000000,
            54 => 0x40000000000000,
            55 => 0x80000000000000,
            56 => 0x100000000000000,
            57 => 0x200000000000000,
            58 => 0x400000000000000,
            59 => 0x800000000000000,
            60 => 0x1000000000000000,
            61 => 0x2000000000000000,
            62 => 0x4000000000000000,
            63 => 0x8000000000000000,
            64 => 0x10000000000000000,
            65 => 0x20000000000000000,
            66 => 0x40000000000000000,
            67 => 0x80000000000000000,
            68 => 0x100000000000000000,
            69 => 0x200000000000000000,
            70 => 0x400000000000000000,
            71 => 0x800000000000000000,
            72 => 0x1000000000000000000,
            73 => 0x2000000000000000000,
            74 => 0x4000000000000000000,
            75 => 0x8000000000000000000,
            76 => 0x10000000000000000000,
            77 => 0x20000000000000000000,
            78 => 0x40000000000000000000,
            79 => 0x80000000000000000000,
            80 => 0x100000000000000000000,
            81 => 0x200000000000000000000,
            82 => 0x400000000000000000000,
            83 => 0x800000000000000000000,
            84 => 0x1000000000000000000000,
            85 => 0x2000000000000000000000,
            86 => 0x4000000000000000000000,
            87 => 0x8000000000000000000000,
            88 => 0x10000000000000000000000,
            89 => 0x20000000000000000000000,
            90 => 0x40000000000000000000000,
            91 => 0x80000000000000000000000,
            92 => 0x100000000000000000000000,
            93 => 0x200000000000000000000000,
            94 => 0x400000000000000000000000,
            95 => 0x800000000000000000000000,
            96 => 0x1000000000000000000000000,
            97 => 0x2000000000000000000000000,
            98 => 0x4000000000000000000000000,
            99 => 0x8000000000000000000000000,
            100 => 0x10000000000000000000000000,
            101 => 0x20000000000000000000000000,
            102 => 0x40000000000000000000000000,
            103 => 0x80000000000000000000000000,
            104 => 0x100000000000000000000000000,
            105 => 0x200000000000000000000000000,
            106 => 0x400000000000000000000000000,
            107 => 0x800000000000000000000000000,
            108 => 0x1000000000000000000000000000,
            109 => 0x2000000000000000000000000000,
            110 => 0x4000000000000000000000000000,
            111 => 0x8000000000000000000000000000,
            112 => 0x10000000000000000000000000000,
            113 => 0x20000000000000000000000000000,
            114 => 0x40000000000000000000000000000,
            115 => 0x80000000000000000000000000000,
            116 => 0x100000000000000000000000000000,
            117 => 0x200000000000000000000000000000,
            118 => 0x400000000000000000000000000000,
            119 => 0x800000000000000000000000000000,
            120 => 0x1000000000000000000000000000000,
            121 => 0x2000000000000000000000000000000,
            122 => 0x4000000000000000000000000000000,
            123 => 0x8000000000000000000000000000000,
            124 => 0x10000000000000000000000000000000,
            125 => 0x20000000000000000000000000000000,
            126 => 0x40000000000000000000000000000000,
            127 => 0x80000000000000000000000000000000,
            128 => 0x100000000000000000000000000000000,
            129 => 0x200000000000000000000000000000000,
            130 => 0x400000000000000000000000000000000,
            131 => 0x800000000000000000000000000000000,
            132 => 0x1000000000000000000000000000000000,
            133 => 0x2000000000000000000000000000000000,
            134 => 0x4000000000000000000000000000000000,
            135 => 0x8000000000000000000000000000000000,
            136 => 0x10000000000000000000000000000000000,
            137 => 0x20000000000000000000000000000000000,
            138 => 0x40000000000000000000000000000000000,
            139 => 0x80000000000000000000000000000000000,
            140 => 0x100000000000000000000000000000000000,
            141 => 0x200000000000000000000000000000000000,
            142 => 0x400000000000000000000000000000000000,
            143 => 0x800000000000000000000000000000000000,
            144 => 0x1000000000000000000000000000000000000,
            145 => 0x2000000000000000000000000000000000000,
            146 => 0x4000000000000000000000000000000000000,
            147 => 0x8000000000000000000000000000000000000,
            148 => 0x10000000000000000000000000000000000000,
            149 => 0x20000000000000000000000000000000000000,
            150 => 0x40000000000000000000000000000000000000,
            151 => 0x80000000000000000000000000000000000000,
            152 => 0x100000000000000000000000000000000000000,
            153 => 0x200000000000000000000000000000000000000,
            154 => 0x400000000000000000000000000000000000000,
            155 => 0x800000000000000000000000000000000000000,
            156 => 0x1000000000000000000000000000000000000000,
            157 => 0x2000000000000000000000000000000000000000,
            158 => 0x4000000000000000000000000000000000000000,
            159 => 0x8000000000000000000000000000000000000000,
            160 => 0x10000000000000000000000000000000000000000,
            161 => 0x20000000000000000000000000000000000000000,
            162 => 0x40000000000000000000000000000000000000000,
            163 => 0x80000000000000000000000000000000000000000,
            164 => 0x100000000000000000000000000000000000000000,
            165 => 0x200000000000000000000000000000000000000000,
            166 => 0x400000000000000000000000000000000000000000,
            167 => 0x800000000000000000000000000000000000000000,
            168 => 0x1000000000000000000000000000000000000000000,
            169 => 0x2000000000000000000000000000000000000000000,
            170 => 0x4000000000000000000000000000000000000000000,
            171 => 0x8000000000000000000000000000000000000000000,
            172 => 0x10000000000000000000000000000000000000000000,
            173 => 0x20000000000000000000000000000000000000000000,
            174 => 0x40000000000000000000000000000000000000000000,
            175 => 0x80000000000000000000000000000000000000000000,
            176 => 0x100000000000000000000000000000000000000000000,
            177 => 0x200000000000000000000000000000000000000000000,
            178 => 0x400000000000000000000000000000000000000000000,
            179 => 0x800000000000000000000000000000000000000000000,
            180 => 0x1000000000000000000000000000000000000000000000,
            181 => 0x2000000000000000000000000000000000000000000000,
            182 => 0x4000000000000000000000000000000000000000000000,
            183 => 0x8000000000000000000000000000000000000000000000,
            184 => 0x10000000000000000000000000000000000000000000000,
            185 => 0x20000000000000000000000000000000000000000000000,
            186 => 0x40000000000000000000000000000000000000000000000,
            187 => 0x80000000000000000000000000000000000000000000000,
            188 => 0x100000000000000000000000000000000000000000000000,
            189 => 0x200000000000000000000000000000000000000000000000,
            190 => 0x400000000000000000000000000000000000000000000000,
            191 => 0x800000000000000000000000000000000000000000000000,
            192 => 0x1000000000000000000000000000000000000000000000000,
            193 => 0x2000000000000000000000000000000000000000000000000,
            194 => 0x4000000000000000000000000000000000000000000000000,
            195 => 0x8000000000000000000000000000000000000000000000000,
            196 => 0x10000000000000000000000000000000000000000000000000,
            197 => 0x20000000000000000000000000000000000000000000000000,
            198 => 0x40000000000000000000000000000000000000000000000000,
            199 => 0x80000000000000000000000000000000000000000000000000,
            200 => 0x100000000000000000000000000000000000000000000000000,
            201 => 0x200000000000000000000000000000000000000000000000000,
            202 => 0x400000000000000000000000000000000000000000000000000,
            203 => 0x800000000000000000000000000000000000000000000000000,
            204 => 0x1000000000000000000000000000000000000000000000000000,
            205 => 0x2000000000000000000000000000000000000000000000000000,
            206 => 0x4000000000000000000000000000000000000000000000000000,
            207 => 0x8000000000000000000000000000000000000000000000000000,
            208 => 0x10000000000000000000000000000000000000000000000000000,
            209 => 0x20000000000000000000000000000000000000000000000000000,
            210 => 0x40000000000000000000000000000000000000000000000000000,
            211 => 0x80000000000000000000000000000000000000000000000000000,
            212 => 0x100000000000000000000000000000000000000000000000000000,
            213 => 0x200000000000000000000000000000000000000000000000000000,
            214 => 0x400000000000000000000000000000000000000000000000000000,
            215 => 0x800000000000000000000000000000000000000000000000000000,
            216 => 0x1000000000000000000000000000000000000000000000000000000,
            217 => 0x2000000000000000000000000000000000000000000000000000000,
            218 => 0x4000000000000000000000000000000000000000000000000000000,
            219 => 0x8000000000000000000000000000000000000000000000000000000,
            220 => 0x10000000000000000000000000000000000000000000000000000000,
            221 => 0x20000000000000000000000000000000000000000000000000000000,
            222 => 0x40000000000000000000000000000000000000000000000000000000,
            223 => 0x80000000000000000000000000000000000000000000000000000000,
            224 => 0x100000000000000000000000000000000000000000000000000000000,
            225 => 0x200000000000000000000000000000000000000000000000000000000,
            226 => 0x400000000000000000000000000000000000000000000000000000000,
            227 => 0x800000000000000000000000000000000000000000000000000000000,
            228 => 0x1000000000000000000000000000000000000000000000000000000000,
            229 => 0x2000000000000000000000000000000000000000000000000000000000,
            230 => 0x4000000000000000000000000000000000000000000000000000000000,
            231 => 0x8000000000000000000000000000000000000000000000000000000000,
            232 => 0x10000000000000000000000000000000000000000000000000000000000,
            233 => 0x20000000000000000000000000000000000000000000000000000000000,
            234 => 0x40000000000000000000000000000000000000000000000000000000000,
            235 => 0x80000000000000000000000000000000000000000000000000000000000,
            236 => 0x100000000000000000000000000000000000000000000000000000000000,
            237 => 0x200000000000000000000000000000000000000000000000000000000000,
            238 => 0x400000000000000000000000000000000000000000000000000000000000,
            239 => 0x800000000000000000000000000000000000000000000000000000000000,
            240 => 0x1000000000000000000000000000000000000000000000000000000000000,
            241 => 0x2000000000000000000000000000000000000000000000000000000000000,
            242 => 0x4000000000000000000000000000000000000000000000000000000000000,
            243 => 0x8000000000000000000000000000000000000000000000000000000000000,
            244 => 0x10000000000000000000000000000000000000000000000000000000000000,
            245 => 0x20000000000000000000000000000000000000000000000000000000000000,
            246 => 0x40000000000000000000000000000000000000000000000000000000000000,
            247 => 0x80000000000000000000000000000000000000000000000000000000000000,
            248 => 0x100000000000000000000000000000000000000000000000000000000000000,
            249 => 0x200000000000000000000000000000000000000000000000000000000000000,
            250 => 0x400000000000000000000000000000000000000000000000000000000000000,
            251 => 0x800000000000000000000000000000000000000000000000000000000000000,
            _ => 0,
        }
    }

    #[inline]
    fn reseed(seed: felt252) -> felt252 {
        let mut state = PoseidonTrait::new();
        state = state.update(seed);
        state.finalize()
    }
}

#[generate_trait]
impl MazeAssert of AssertTrait {
    #[inline]
    fn assert_on_edge(ref self: Maze, position: u8) {
        let (x, y) = (position % self.width, position / self.width);
        assert(
            x == 0 || x == self.width - 1 || y == 0 || y == self.height - 1,
            errors::MAZE_INVALID_EXIT
        );
    }

    #[inline]
    fn assert_not_corner(ref self: Maze, position: u8) {
        let (x, y) = (position % self.width, position / self.width);
        assert(x != 0 || y != 0, errors::MAZE_INVALID_EXIT);
        assert(x != self.width - 1 || y != 0, errors::MAZE_INVALID_EXIT);
        assert(x != 0 || y != self.height - 1, errors::MAZE_INVALID_EXIT);
        assert(x != self.width - 1 || y != self.height - 1, errors::MAZE_INVALID_EXIT);
    }
}

#[cfg(test)]
mod tests {
    // Local imports

    use super::{Maze, MazeTrait};

    // Constants

    const SEED: felt252 = 'SEED';

    #[test]
    fn test_maze_new_seed() {
        // 000000000000000
        // 010111110111110
        // 010101010000010
        // 011101010111110
        // 000001010100010
        // 011111011101010
        // 010000000001010
        // 010111111111110
        // 010000000001000
        // 011111111101110
        // 010000000100000
        // 011111110111110
        // 000000010000010
        // 011111111111010
        // 000000000000010
        let width = 15;
        let height = 15;
        let start_index: u8 = 1;
        let mut maze: Maze = MazeTrait::new(width, height, start_index, SEED);
        assert_eq!(maze.grid, 0x17df2a82757c0a89f75200a5ffc8021ff720207f7c0209ffd0002);
    }

    #[test]
    fn test_maze_add_exit() {
        // 001000000000000
        // 011111110111110
        // 010101010000010
        // 011101010111110
        // 000001010100010
        // 011111011101010
        // 010000000001010
        // 010111111111110
        // 010000000001000
        // 011111111101110
        // 010000000100000
        // 011111110111110
        // 000000010000010
        // 011111111111010
        // 000000000000010
        let width = 15;
        let height = 15;
        let start_index: u8 = 1;
        let mut maze: Maze = MazeTrait::new(width, height, start_index, SEED);
        maze.add_exit(222);
        assert_eq!(maze.grid, 0x4001fdf2a82757c0a89f75200a5ffc8021ff720207f7c0209ffd0002);
    }

    #[test]
    fn test_maze_add_exit_twice() {
        // 001000000000000
        // 111111110111110
        // 010101010000010
        // 011101010111110
        // 000001010100010
        // 011111011101010
        // 010000000001010
        // 010111111111110
        // 010000000001000
        // 011111111101110
        // 010000000100000
        // 011111110111110
        // 000000010000010
        // 011111111111010
        // 000000000000010
        let width = 15;
        let height = 15;
        let start_index: u8 = 1;
        let mut maze: Maze = MazeTrait::new(width, height, start_index, SEED);
        maze.add_exit(222);
        maze.add_exit(209);
        assert_eq!(maze.grid, 0x4003fdf2a82757c0a89f75200a5ffc8021ff720207f7c0209ffd0002);
    }
}
